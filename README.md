
Звіт: Лабораторна Робота з Аналізу Продуктивності

Назва: Аналіз продуктивності, профілювання та енергоефективності C++ програми за допомогою perf, FlameGraph та cpupower.

Мета роботи: Опанувати методи профілювання програм у середовищі Linux; навчитися будувати та інтерпретувати FlameGraph; збирати та аналізувати апаратну статистику за допомогою perf stat; вимірювати та порівнювати енергоспоживання (Джоулі) та потужність (Вати) програми до та після оптимізації; візуально аналізувати ефект оптимізації на рівні асемблерного коду.

Обладнання та Програмне Забезпечення:

    ОС: Linux Mint (Ядро 6.14.0-29)

    Процесор: (ASUS-TUF-Dash-F15 з підтримкою intel_pstate та RAPL)

    Компілятор: g++

    Інструменти аналізу: perf (версії 6.8.0-87), FlameGraph, /usr/bin/time, cpupower.

1. Підготовка та Створення Експериментального Коду

    Програма: Була написана C++ програма primes.cpp, яка реалізує "наївний" (неоптимізований, O(n)) алгоритм пошуку простих чисел.

    Калібрування: Емпіричним шляхом було підібрано вхідне значення n = 300000, при якому неоптимізована програма виконувалася ~8.5 секунд, що достатньо для збору даних профілювання.

2. Аналіз НЕОПТИМІЗОВАНОЇ версії (primes_O0)

    Компіляція: g++ -O0 -g primes.cpp -o primes_O0

2.1. Побудова та Інтерпретація FlameGraph (п. 1)

    Результат: **

    Інтерпретація: Графік чітко показує, що 99%+ часу CPU витрачається всередині функції isPrime. Це вказує на те, що isPrime є єдиним "гарячим місцем" (hotspot) програми. Вся подальша оптимізація має бути зосереджена на ній.

2.2. Збір та Аналіз Статистики (п. 2)

    /usr/bin/time --verbose:

        User time: 8.52s, System time: 0.00s.

        Висновок: Програма є на 100% CPU-bound, оскільки вона не виконує жодних системних викликів чи операцій I/O.

    perf stat -d:

        Instructions: 26.1 млрд

        IPC (Insn per cycle): 1.40

        CPU Frequency (avg): 2.178 ГГц

        Висновок: Код виконує величезну кількість інструкцій, але з відносно непоганою ефективністю (IPC > 1.0). Процесор працює на стабільній, не-турбо частоті.

    perf report:

        Висновок: Підтвердив дані FlameGraph, показавши, що 99.57% часу Self припадає на isPrime.

2.3. Вимірювання Енерговитрат (п. 3)

    Метод: Оскільки powerstat виявився непридатним для короткочасних вимірювань, було використано perf stat з подіями RAPL (power/energy-pkg/ та power/energy-cores/).

    Результати (primes_O0):

        Час: 8.53 с

        Енергія (Ядра): 47.97 Джоулів

        Енергія (Пакет CPU): 93.72 Джоулів

        Середня Потужність (Пакет): 11.0 Вт

3. Аналіз ОПТИМІЗОВАНИХ версій та Порівняння (п. 4)

Було проведено два додаткові експерименти для порівняння:

    Тест "Performance": Програма скомпільована з g++ -O3 і запущена в режимі максимальної продуктивності (performance governor, Turbo Boost до 4.7 ГГц).

    Тест "Eco": Та ж програма primes_O3, але з примусовим обмеженням частоти CPU до 1.5 ГГц за допомогою cpupower.

3.1. Фінальна Порівняльна Таблиця (п. 4.2, 4.4)

Показник	Тест 1: primes_O0 (Baseline)	Тест 2: primes_O3 (Performance)	Тест 3: primes_O3 (Eco @ 1.5G)
Час виконання	8.53 с	4.17 с (Найшвидший)	12.53 с (Найповільніший)
Інструкції	26.1 млрд	14.9 млрд	14.9 млрд
Середня частота CPU	2.18 ГГц	4.51 ГГц (Turbo Boost)	1.50 ГГц (Обмежено)
IPC (Інстр./Цикл)	1.40 (Найкращий)	0.80	0.79 (Найгірший)
Енергія (Ядра)	47.97 Дж (Найкраща)	84.72 Дж	48.52 Дж
Енергія (Пакет CPU)	93.72 Дж (Найкраща)	107.41 Дж	115.16 Дж (Найгірша)
Сер. Потужність (Пакет)	11.0 Вт	25.8 Вт	9.2 Вт (Найнижча)

3.2. Аналіз Асемблерного коду (п. 4.1, 4.1.1)

    Inlining (Вбудовування): Аналіз на godbolt.org показав, що -O0 використовує інструкцію call isPrime. У версії -O3 ця інструкція відсутня. Компілятор вбудував тіло isPrime безпосередньо в цикл main, усунувши мільярди дорогих викликів функцій.

    SIMD (Векторизація): У коді -O3 з'явилися SIMD-інструкції (напр., movdqa, pxor), яких не було в -O0. Це свідчить про те, що компілятор векторизував код для паралельної обробки даних.

    Висновок (п. 4.1): Оптимізація -O3 кардинально змінила код, що призвело до зменшення загальної кількості інструкцій на 43% (з 26.1 до 14.9 млрд).

3.3. Аналіз FlameGraph після оптимізації (п. 4.3)

    Результат: **

    Інтерпретація: Графік primes_O3.svg візуально підтверджує inlining. "Башта" виклику зникла. Графік "плаский", і вся робота (найширший блок) тепер приписана функції main.

4. Загальні Висновки

    Оптимізація — це компроміс. Оптимізація -O3 (Тест 2) була спрямована виключно на швидкість. Вона досягла мети (прискорення в 2.05 рази), але зробила це ціною значно вищого енергоспоживання. Код став "важчим" (IPC впав з 1.40 до 0.80), що змусило процесор увімкнути Turbo Boost (4.5 ГГц) і збільшити середню потужність з 11 Вт до 25.8 Вт.

    Парадокс "Race-to-Sleep". Експеримент з обмеженням частоти (Тест 3) довів, що для CPU-bound задач стратегія "працюй повільно, але економно" є програшною. Хоча середня потужність (Вати) була найнижчою (9.2 Вт), довгий час роботи (12.53с) призвів до того, що "паразитне" споживання неактивних частин процесора ("uncore") накопичилося і дало найгірший результат за сумарною енергією (115.16 Дж).

    Несподіваний переможець в енергоефективності. Найбільш збалансованим і, зрештою, найефективнішим за загальною витратою енергії (93.72 Дж) виявився неоптимізований код primes_O0 (Тест 1). Його "простий" код мав найкращий IPC (1.40) і виконувався на стабільній, середній частоті, не вмикаючи енергозатратний Turbo Boost. Це демонструє, що "розумна" оптимізація не завжди є найенергоефективнішою.
